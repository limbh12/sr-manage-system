# 변경 이력 - 2025-12-11

## SR 소프트 삭제 및 복구 기능 구현

### 개요
SR 관리 시스템에 소프트 삭제(Soft Delete) 및 복구(Restore) 기능을 구현했습니다. 물리적 삭제 대신 삭제 플래그를 설정하여 데이터를 보존하고, 관리자가 삭제된 항목을 복구할 수 있도록 했습니다.

---

## 주요 변경 사항

### 1. 소프트 삭제 기능

#### Backend 구현

**Sr 엔티티 (`Sr.java`)**
- `deleted` 필드 추가: 삭제 여부를 나타내는 Boolean 플래그 (기본값: false)
- `deletedAt` 필드 추가: 삭제 일시를 기록하는 LocalDateTime
- `restore()` 메서드 추가: 삭제를 취소하는 복구 메서드

```java
/** 삭제 여부 (소프트 삭제) */
@Column(nullable = false)
@Builder.Default
private Boolean deleted = false;

/** 삭제 일시 */
private LocalDateTime deletedAt;

/**
 * SR 복구 (소프트 삭제 취소)
 */
public void restore() {
    this.deleted = false;
    this.deletedAt = null;
}
```

**SrRepository (`SrRepository.java`)**
- 삭제 여부 기반 쿼리 메서드 추가:
  - `findByDeleted(Boolean deleted, Pageable pageable)`
  - `findByStatusAndDeleted(SrStatus status, Boolean deleted, Pageable pageable)`
  - `findByPriorityAndDeleted(Priority priority, Boolean deleted, Pageable pageable)`
  - `findByStatusAndPriorityAndDeleted(...)`
  - `searchByTitleOrDescriptionAndDeleted(...)`

**SrService (`SrService.java`)**
- `deleteSr()` 메서드를 소프트 삭제로 변경:
  - 물리적 삭제 대신 `deleted` 플래그를 true로 설정
  - `deletedAt`에 현재 시각 기록
  - 삭제 이력 자동 생성
- `getSrList()` 메서드에 `includeDeleted` 파라미터 추가:
  - 관리자가 삭제된 항목 포함 여부 선택 가능
  - 삭제 여부에 따라 적절한 Repository 메서드 호출

```java
// 소프트 삭제: deleted 플래그를 true로 설정
sr.setDeleted(true);
sr.setDeletedAt(LocalDateTime.now());
srRepository.save(sr);

// 삭제 이력 기록
createHistory(sr, "SR이 삭제되었습니다.", SrHistoryType.INFO_CHANGE, user);
```

**SrController (`SrController.java`)**
- `getSrList()` API에 `includeDeleted` 파라미터 추가:
  - 관리자 권한 체크 로직 구현
  - 관리자가 아닌 경우 삭제된 항목 조회 불가

```java
// 관리자가 아닌 경우 삭제된 항목 포함 불가
Boolean showDeleted = false;
if (includeDeleted != null && includeDeleted) {
    User user = userRepository.findByUsername(authentication.getName())
            .orElseThrow(() -> new CustomException("User not found", HttpStatus.NOT_FOUND));
    if (user.getRole() == Role.ADMIN) {
        showDeleted = true;
    }
}
```

**Database Schema (`schema-cubrid.sql`)**
- `sr` 테이블에 컬럼 추가:
  - `deleted BOOLEAN NOT NULL DEFAULT FALSE`
  - `deleted_at TIMESTAMP`

#### Frontend 구현

**Types (`types/index.ts`)**
- `Sr` 인터페이스에 필드 추가:
  - `deleted?: boolean`
  - `deletedAt?: string`

**SR Service (`srService.ts`)**
- `GetSrListParams` 인터페이스에 `includeDeleted` 추가
- API 호출 시 삭제된 항목 포함 여부 전달

**Redux Store (`srSlice.ts`)**
- `FetchSrListParams`에 `includeDeleted` 파라미터 추가
- 목록 조회 시 삭제된 항목 필터링 지원

**Custom Hook (`useSr.ts`)**
- `FetchSrListParams`에 `includeDeleted` 추가
- 컴포넌트에서 삭제된 항목 조회 제어 가능

**SR List Component (`SrList.tsx`)**
- 삭제된 항목 시각적 표시:
  - 행 투명도 60%로 설정 (`opacity: 0.6`)
  - 제목에 취소선 스타일 적용 (`text-decoration: line-through`)
  - "(삭제됨)" 라벨 표시
- 삭제 버튼은 삭제되지 않은 항목에만 표시

```typescript
<tr key={sr.id} style={{ opacity: sr.deleted ? 0.6 : 1 }}>
  <td>
    <a style={{
      color: '#1976d2',
      textDecoration: sr.deleted ? 'line-through' : 'none'
    }}>
      {sr.title}
    </a>
    {sr.deleted && <span style={{ marginLeft: '8px', color: '#999', fontSize: '12px' }}>(삭제됨)</span>}
  </td>
  ...
  <td>
    {!sr.deleted && (
      <button className="btn btn-danger" onClick={() => onDeleteSr(sr.id)}>
        삭제
      </button>
    )}
  </td>
</tr>
```

**SR Management Page (`SrManagementPage.tsx`)**
- "삭제된 항목 포함" 체크박스 추가:
  - 관리자에게만 표시 (`{isAdmin && (...)`)
  - 체크 시 삭제된 SR 목록 포함 조회
  - 체크박스 변경 시 즉시 목록 갱신

```typescript
{isAdmin && (
  <div className="form-group" style={{ marginBottom: 0 }}>
    <label style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer' }}>
      <input
        type="checkbox"
        checked={includeDeleted}
        onChange={(e) => {
          const checked = e.target.checked;
          setIncludeDeleted(checked);
          fetchSrList({
            page: 0,
            status: statusFilter || undefined,
            priority: priorityFilter || undefined,
            search: searchQuery || undefined,
            includeDeleted: checked,
          });
        }}
        style={{ cursor: 'pointer' }}
      />
      <span>삭제된 항목 포함</span>
    </label>
  </div>
)}
```

---

### 2. SR 복구 기능 (관리자 전용)

#### Backend 구현

**SrService (`SrService.java`)**
- `restoreSr()` 메서드 추가:
  - 관리자 권한 체크 (관리자만 복구 가능)
  - 이미 복구된 SR인지 확인
  - `restore()` 메서드 호출하여 복구
  - 복구 이력 자동 생성

```java
/**
 * SR 복구 (소프트 삭제 취소) - 관리자 전용
 */
@Transactional
public SrResponse restoreSr(Long id, String username) {
    Sr sr = srRepository.findById(id)
            .orElseThrow(() -> new CustomException("SR not found with id: " + id, HttpStatus.NOT_FOUND));

    User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new CustomException("User not found", HttpStatus.NOT_FOUND));

    // 권한 체크: 관리자만 복구 가능
    if (user.getRole() != Role.ADMIN) {
        throw new CustomException("복구 권한이 없습니다. 관리자만 복구할 수 있습니다.", HttpStatus.FORBIDDEN);
    }

    // 이미 복구된 SR인지 확인
    if (!sr.getDeleted()) {
        throw new CustomException("이미 복구된 SR입니다.", HttpStatus.BAD_REQUEST);
    }

    // SR 복구
    sr.restore();
    Sr restoredSr = srRepository.save(sr);

    // 복구 이력 기록
    createHistory(sr, "SR이 복구되었습니다.", SrHistoryType.INFO_CHANGE, user);

    return SrResponse.from(restoredSr);
}
```

**SrController (`SrController.java`)**
- `POST /api/sr/{id}/restore` 엔드포인트 추가:
  - 관리자만 호출 가능
  - 복구된 SR 정보 반환

```java
/**
 * SR 복구 (소프트 삭제 취소) - 관리자 전용
 */
@PostMapping("/{id}/restore")
public ResponseEntity<SrResponse> restoreSr(@PathVariable Long id, Authentication authentication) {
    SrResponse response = srService.restoreSr(id, authentication.getName());
    return ResponseEntity.ok(response);
}
```

#### Frontend 구현

**SR Service (`srService.ts`)**
- `restoreSr()` 함수 추가:
  - POST `/sr/{id}/restore` API 호출
  - Mock 모드에서는 미지원 (에러 throw)

```typescript
/**
 * SR 복구 (관리자 전용)
 */
export const restoreSr = async (id: number): Promise<Sr> => {
  if (USE_MOCK) {
    throw new Error('Mock mode does not support restore functionality');
  }
  const response = await api.post<Sr>(`/sr/${id}/restore`);
  return response.data;
};
```

**Redux Store (`srSlice.ts`)**
- `restoreSrAsync` 비동기 액션 추가
- 복구 완료 시 목록 업데이트 리듀서 구현:
  - `srList`에서 해당 SR 업데이트
  - `currentSr`도 함께 업데이트

```typescript
/**
 * SR 복구 액션 (관리자 전용)
 */
export const restoreSrAsync = createAsyncThunk<Sr, number, { rejectValue: string }>(
  'sr/restore',
  async (id, { rejectWithValue }) => {
    try {
      return await srService.restoreSr(id);
    } catch (error) {
      if (error instanceof Error) {
        return rejectWithValue(error.message);
      }
      return rejectWithValue('Failed to restore SR');
    }
  }
);
```

**Custom Hook (`useSr.ts`)**
- `restoreSr()` 함수 추가 및 export
- Redux 액션 호출 후 성공 여부 반환

**SR List Component (`SrList.tsx`)**
- Props에 `onRestoreSr` 콜백과 `isAdmin` 플래그 추가
- 삭제된 항목에만 "복구" 버튼 표시 (관리자에게만):
  - 조건: `sr.deleted && isAdmin && onRestoreSr`
  - 버튼 클래스: `btn btn-primary`
  - 클릭 시 `onRestoreSr(sr.id)` 호출

```typescript
{sr.deleted && isAdmin && onRestoreSr ? (
  <button
    className="btn btn-primary"
    onClick={() => onRestoreSr(sr.id)}
    style={{ marginRight: '8px' }}
  >
    복구
  </button>
) : null}
```

**SR Management Page (`SrManagementPage.tsx`)**
- `handleRestore()` 핸들러 추가:
  - 확인 다이얼로그 표시
  - 복구 성공 시 목록 갱신
- `SrList`에 복구 관련 props 전달:
  - `onRestoreSr={handleRestore}`
  - `isAdmin={isAdmin}`

```typescript
const handleRestore = async (id: number) => {
  if (window.confirm('이 SR을 복구하시겠습니까?')) {
    const success = await restoreSr(id);
    if (success) {
      // 목록 갱신
      handleSearch();
    }
  }
};
```

---

### 3. 데이터베이스 스키마 업데이트

**DATABASE.md 문서 업데이트**
- SR 테이블 정의에 필드 추가:
  - `deleted`: 삭제 여부 (소프트 삭제)
  - `deleted_at`: 삭제 일시
  - `applicant_name`: 요청자 이름 (이전 누락분 추가)
  - `applicant_phone`: 요청자 연락처 (이전 누락분 추가)
- 모든 DB 방언(CUBRID, MySQL, PostgreSQL)에 스키마 반영
- 인덱스 추가: `INDEX idx_sr_deleted (deleted)`

---

## 적용 파일 목록

### Backend (6개 파일)
1. `backend/src/main/java/com/srmanagement/entity/Sr.java`
   - deleted, deletedAt 필드 추가
   - restore() 메서드 추가

2. `backend/src/main/java/com/srmanagement/repository/SrRepository.java`
   - 삭제 여부 기반 쿼리 메서드 추가

3. `backend/src/main/java/com/srmanagement/service/SrService.java`
   - 소프트 삭제 로직 구현
   - restoreSr() 메서드 추가
   - getSrList에 includeDeleted 지원

4. `backend/src/main/java/com/srmanagement/controller/SrController.java`
   - POST /api/sr/{id}/restore 엔드포인트 추가
   - GET /api/sr에 includeDeleted 파라미터 추가

5. `backend/src/main/java/com/srmanagement/dto/response/SrResponse.java`
   - deleted, deletedAt 필드 추가

6. `backend/src/main/resources/schema-cubrid.sql`
   - sr 테이블에 deleted, deleted_at 컬럼 추가

### Frontend (6개 파일)
1. `frontend/src/types/index.ts`
   - Sr 인터페이스에 deleted, deletedAt 추가

2. `frontend/src/services/srService.ts`
   - GetSrListParams에 includeDeleted 추가
   - restoreSr() 함수 추가

3. `frontend/src/store/srSlice.ts`
   - FetchSrListParams에 includeDeleted 추가
   - restoreSrAsync 액션 추가
   - 복구 리듀서 추가

4. `frontend/src/hooks/useSr.ts`
   - FetchSrListParams에 includeDeleted 추가
   - restoreSr 함수 추가

5. `frontend/src/components/sr/SrList.tsx`
   - 삭제된 항목 시각적 표시
   - 복구 버튼 추가

6. `frontend/src/pages/SrManagementPage.tsx`
   - "삭제된 항목 포함" 체크박스 추가
   - handleRestore 핸들러 추가

### 문서 (1개 파일)
1. `docs/DATABASE.md`
   - SR 테이블 스키마 업데이트

---

## 기능 요약

### ✅ 구현된 기능
1. **소프트 삭제**
   - 물리적 삭제 대신 deleted 플래그 설정
   - 삭제 일시 자동 기록
   - 삭제 이력 자동 생성

2. **삭제된 항목 조회** (관리자 전용)
   - "삭제된 항목 포함" 체크박스
   - 일반 사용자는 체크박스 미표시
   - 관리자만 삭제된 SR 조회 가능

3. **삭제된 항목 시각적 구분**
   - 행 투명도 60%
   - 제목 취소선 표시
   - "(삭제됨)" 라벨 표시

4. **SR 복구** (관리자 전용)
   - "복구" 버튼 (삭제된 항목에만 표시)
   - 관리자 권한 체크
   - 복구 이력 자동 생성
   - 확인 다이얼로그

5. **권한 기반 UI**
   - 관리자: 체크박스 표시, 복구 버튼 표시
   - 일반 사용자: 삭제된 항목 조회 불가

6. **이력 추적**
   - 삭제 시 이력 기록
   - 복구 시 이력 기록
   - SR 상세에서 전체 이력 확인 가능

---

## API 명세

### 1. SR 목록 조회
```
GET /api/sr?includeDeleted={boolean}
```
- **파라미터**: `includeDeleted` (선택, 관리자만 사용)
- **권한**: 인증 필요, 관리자만 삭제된 항목 조회 가능
- **응답**: Page<SrResponse>

### 2. SR 복구
```
POST /api/sr/{id}/restore
```
- **권한**: 관리자 전용
- **응답**: SrResponse (복구된 SR 정보)
- **오류**:
  - 403: 관리자가 아닌 경우
  - 400: 이미 복구된 SR인 경우
  - 404: SR을 찾을 수 없는 경우

---

## 데이터베이스 마이그레이션

### 기존 데이터베이스 업데이트 SQL

**CUBRID / MySQL / PostgreSQL 공통:**
```sql
-- sr 테이블에 컬럼 추가
ALTER TABLE sr ADD COLUMN deleted BOOLEAN NOT NULL DEFAULT FALSE;
ALTER TABLE sr ADD COLUMN deleted_at TIMESTAMP NULL;

-- 인덱스 추가 (선택사항, 성능 향상)
CREATE INDEX idx_sr_deleted ON sr(deleted);
```

---

## 테스트 시나리오

### 1. 소프트 삭제 테스트
1. 일반 사용자로 로그인
2. 자신이 생성한 SR 삭제
3. SR 목록에서 해당 항목이 사라짐 확인
4. 관리자로 로그인
5. "삭제된 항목 포함" 체크
6. 삭제된 SR이 취소선으로 표시됨 확인

### 2. 복구 기능 테스트
1. 관리자로 로그인
2. "삭제된 항목 포함" 체크
3. 삭제된 SR의 "복구" 버튼 클릭
4. 확인 다이얼로그에서 확인
5. SR이 복구되어 정상 표시됨 확인
6. SR 상세 → 이력에서 "SR이 복구되었습니다" 확인

### 3. 권한 테스트
1. 일반 사용자로 로그인
2. "삭제된 항목 포함" 체크박스가 보이지 않음 확인
3. API로 직접 복구 시도 시 403 오류 확인
4. 관리자로 로그인
5. 체크박스와 복구 버튼이 정상 표시됨 확인

---

## 주의사항

### 개발 환경
- 기존 H2 데이터베이스 사용 시 스키마가 자동으로 재생성됨 (`ddl-auto: create`)
- 데이터 보존이 필요한 경우 `ddl-auto: update` 사용 권장

### 운영 환경
- 운영 DB에 반드시 마이그레이션 SQL 실행 필요
- 기존 SR 데이터는 `deleted = false`로 자동 설정됨
- 백업 후 마이그레이션 수행 권장

### Mock 모드
- Mock 모드에서는 복구 기능 미지원
- `USE_MOCK = false`로 설정하여 실제 API 사용 권장

---

## 향후 개선 사항

1. **물리적 삭제 기능** (선택)
   - 삭제된 지 일정 기간(예: 30일) 경과한 SR 자동 삭제
   - 관리자 설정 화면에서 보관 기간 설정

2. **삭제 사유 기록**
   - 삭제 시 사유 입력 받기
   - 이력에 사유 포함

3. **대량 복구 기능**
   - 여러 SR을 한 번에 복구
   - 체크박스로 선택 후 일괄 복구

4. **삭제 통계**
   - 대시보드에 삭제된 SR 통계 표시
   - 복구율, 삭제 사유 분석

---

## 커밋 정보
- **커밋 해시**: `3884de8`
- **커밋 날짜**: 2025-12-11
- **변경 파일**: 13개
- **추가 라인**: 412줄
- **삭제 라인**: 67줄

---

## SR 수정 모달에 처리상태 선택 기능 추가

### 개요
SR 등록/수정 모달창에서 처리상태(Status)를 직접 확인하고 변경할 수 있는 기능을 추가했습니다. 수정 모드에서만 처리상태 선택 드롭다운이 표시됩니다.

---

### 주요 변경 사항

#### Frontend 구현

**SrForm 컴포넌트 (`SrForm.tsx`)**
- `SrStatus` 타입 import 추가 (line 2)
- `status` state 추가 (line 25): 처리상태 관리
- SR 수정 시 기존 상태 로드 (line 53): `setStatus(sr.status)`
- 제출 시 상태 포함 (line 125): 수정 요청 시 `status` 필드 전송
- UI 레이아웃 변경 (line 388-431):
  - 우선순위와 처리상태를 나란히 배치 (flex layout)
  - 수정 모드(`isEditMode`)일 때만 처리상태 선택 필드 표시
  - 선택 옵션:
    - **접수** (OPEN)
    - **진행중** (IN_PROGRESS)
    - **해결됨** (RESOLVED)
    - **종료** (CLOSED)

```typescript
const [status, setStatus] = useState<SrStatus>('OPEN');

// SR 수정 시 기존 상태 로드
useEffect(() => {
  if (sr) {
    // ...
    setStatus(sr.status);
    // ...
  }
}, [sr]);

// 제출 시 상태 포함
if (isEditMode) {
  onSubmit({
    ...commonData,
    processingDetails,
    status,  // 처리상태 포함
  } as SrUpdateRequest);
}
```

UI 레이아웃:
```tsx
<div className="form-group">
  <div style={{ display: 'flex', gap: '16px' }}>
    <div style={{ flex: 1 }}>
      <label htmlFor="priority" className="form-label">
        우선순위
      </label>
      <select id="priority" className="form-select" value={priority}
              onChange={(e) => setPriority(e.target.value as Priority)}>
        <option value="LOW">낮음</option>
        <option value="MEDIUM">보통</option>
        <option value="HIGH">높음</option>
        <option value="CRITICAL">긴급</option>
      </select>
    </div>

    {isEditMode && (
      <div style={{ flex: 1 }}>
        <label htmlFor="status" className="form-label">
          처리상태
        </label>
        <select id="status" className="form-select" value={status}
                onChange={(e) => setStatus(e.target.value as SrStatus)}>
          <option value="OPEN">접수</option>
          <option value="IN_PROGRESS">진행중</option>
          <option value="RESOLVED">해결됨</option>
          <option value="CLOSED">종료</option>
        </select>
      </div>
    )}
  </div>
</div>
```

---

### Backend 호환성 확인

**SrUpdateRequest DTO (`SrUpdateRequest.java`)**
- 이미 `status` 필드 존재 (line 29) ✅
- 타입: `SrStatus` (OPEN, IN_PROGRESS, RESOLVED, CLOSED)
- 변경 불필요

**TypeScript 타입 정의 (`types/index.ts`)**
- `SrUpdateRequest` 인터페이스에 `status?: SrStatus` 존재 (line 116) ✅
- 변경 불필요

---

### 적용 파일 목록

#### Frontend (1개 파일)
1. `frontend/src/components/sr/SrForm.tsx`
   - SrStatus 타입 import
   - status state 추가
   - 기존 SR 로드 시 status 설정
   - 제출 시 status 포함
   - UI에 처리상태 선택 드롭다운 추가

---

### 기능 요약

#### ✅ 구현된 기능
1. **SR 등록 모드**
   - 처리상태 필드 미표시
   - 새 SR은 자동으로 `OPEN` 상태로 생성됨

2. **SR 수정 모드**
   - 우선순위 옆에 처리상태 선택 드롭다운 표시
   - 현재 처리상태 확인 가능
   - 드롭다운에서 상태 변경 가능
   - 4가지 상태 중 선택: 접수, 진행중, 해결됨, 종료

3. **상태 흐름**
   - OPEN (접수) → IN_PROGRESS (진행중) → RESOLVED (해결됨) → CLOSED (종료)
   - 모달에서 직접 상태 전환 가능
   - 변경 시 SR 이력에 자동 기록 (기존 기능)

---

### 사용 시나리오

#### 시나리오 1: SR 수정 및 상태 변경
1. SR 목록에서 항목 클릭하여 수정 모달 열기
2. 우선순위 옆에 현재 처리상태 확인
3. 처리상태 드롭다운에서 새로운 상태 선택 (예: "접수" → "진행중")
4. 처리내용 입력
5. "수정" 버튼 클릭
6. SR 상세 → 이력에서 상태 변경 기록 확인

#### 시나리오 2: SR 등록
1. "SR 등록" 버튼 클릭
2. 처리상태 필드가 표시되지 않음 (신규 SR은 자동으로 OPEN)
3. 요청자 정보, 제목, 요청사항 등 입력
4. "등록" 버튼 클릭
5. 생성된 SR은 "접수" 상태로 시작

---

### 개선 효과

1. **사용자 편의성 향상**
   - 상태 변경을 위해 별도 API를 호출하지 않아도 됨
   - 수정 모달에서 한 번에 모든 정보 변경 가능

2. **일관된 UX**
   - 다른 필드(우선순위, 담당자 등)와 동일한 방식으로 상태 변경
   - 수정 폼에서 모든 정보를 한눈에 확인 가능

3. **권한 관리**
   - 기존 SR 수정 권한과 동일하게 적용됨
   - 별도의 상태 변경 권한 체크 불필요

---

### 주의사항

- 기존의 상태 변경 API (`PATCH /api/sr/{id}/status`)는 그대로 유지됨
- 상태 변경 시 자동으로 이력이 기록됨 (Backend SrService의 기존 기능)
- 삭제된 SR은 수정할 수 없으므로 상태 변경도 불가능함

---

### 향후 개선 가능 사항

1. **상태 전환 검증**
   - 현재는 모든 상태로 자유롭게 전환 가능
   - 필요 시 상태 전환 규칙 추가 가능 (예: CLOSED → OPEN 불가)

2. **상태 변경 이유 입력**
   - 상태 변경 시 변경 이유를 입력받아 이력에 포함
   - 특히 CLOSED → 다른 상태로 변경 시 유용

3. **상태별 필수 필드 검증**
   - RESOLVED 또는 CLOSED로 변경 시 처리내용 필수 입력
   - Frontend에서 validation 추가 가능

---

### 커밋 정보
- **커밋 날짜**: 2025-12-11
- **변경 파일**: 2개 (SrForm.tsx, HISTORY_20251211.md)
- **추가 라인**: 239줄
- **수정 라인**: 18줄
- **커밋 해시**: `233804d`

---

## OPEN API 현황조사 담당자 직급 필드 추가

### 개요
OPEN API 현황조사 기본정보에 담당자의 직급(contactPosition) 항목을 추가했습니다. 선택 입력 필드로 구현되어 기존 데이터와의 호환성을 유지합니다.

---

### 주요 변경 사항

#### Backend 구현

**OpenApiSurvey Entity (`OpenApiSurvey.java`)**
- `contactPosition` 필드 추가 (line 37-38)
- 타입: `String`
- 길이: 50자
- NULL 허용 (선택 입력)

```java
@Column(length = 50)
private String contactPosition;
```

**DTOs**
1. `OpenApiSurveyResponse` (line 19): `contactPosition` 필드 추가
2. `OpenApiSurveyCreateRequest` (line 17): `contactPosition` 필드 추가

**OpenApiSurveyService (`OpenApiSurveyService.java`)**
- 생성 로직에 직급 필드 매핑 추가 (line 147)
- 응답 생성 시 직급 필드 포함 (line 394)

```java
// Survey 생성
.contactName(request.getContactName())
.contactPosition(request.getContactPosition())
.contactPhone(request.getContactPhone())

// Response 매핑
.contactName(survey.getContactName())
.contactPosition(survey.getContactPosition())
.contactPhone(survey.getContactPhone())
```

**Database Schema (`schema-cubrid.sql`)**
- `open_api_survey` 테이블에 컬럼 추가 (line 37)

```sql
CREATE TABLE open_api_survey (
    ...
    contact_name VARCHAR(50) NOT NULL,
    contact_position VARCHAR(50),
    contact_phone VARCHAR(30) NOT NULL,
    ...
);
```

#### Frontend 구현

**Types (`types/index.ts`)**
- `OpenApiSurvey` 인터페이스에 `contactPosition` 필드 추가 (line 276)
- 선택 필드로 정의: `contactPosition?: string`

**SurveyForm (`SurveyForm.tsx`)**
- 담당자명과 연락처 사이에 직급 입력 필드 추가 (line 264-267)
- 선택 입력 (required 없음)
- placeholder: "예: 주무관, 팀장 등"

```tsx
<div className="form-group">
  <label className="form-label">직급</label>
  <input
    type="text"
    name="contactPosition"
    className="form-input"
    value={formData.contactPosition || ''}
    onChange={handleChange}
    placeholder="예: 주무관, 팀장 등"
  />
</div>
```

**OpenApiSurveyInfoCard (`OpenApiSurveyInfoCard.tsx`)**
- 담당자 필드에 직급 표시 추가 (line 81)
- 직급이 있으면 "이름 (직급)" 형식으로 표시
- 직급이 없으면 이름만 표시

```tsx
{renderField('담당자',
  survey.contactPosition
    ? `${survey.contactName} (${survey.contactPosition})`
    : survey.contactName
)}
```

---

### 데이터베이스 마이그레이션

**마이그레이션 스크립트**

1. `migration_20251211_contact_position.sql` - CUBRID/MySQL/PostgreSQL 공통
```sql
ALTER TABLE open_api_survey ADD COLUMN contact_position VARCHAR(50);
```

2. `migration_20251211_contact_position_h2.sql` - H2 전용
```sql
ALTER TABLE open_api_survey ADD COLUMN IF NOT EXISTS contact_position VARCHAR(50);
```

**적용 방법**
```bash
# 운영 DB (CUBRID/MySQL/PostgreSQL)
mysql -u user -p database < migration_20251211_contact_position.sql

# H2 (개발 환경)
# application.yml에서 ddl-auto: update 사용 시 자동 적용
# 또는 H2 Console에서 수동 실행
```

---

### 적용 파일 목록

#### Backend (5개 파일)
1. `backend/src/main/java/com/srmanagement/entity/OpenApiSurvey.java`
   - contactPosition 필드 추가

2. `backend/src/main/java/com/srmanagement/dto/response/OpenApiSurveyResponse.java`
   - contactPosition 필드 추가

3. `backend/src/main/java/com/srmanagement/dto/request/OpenApiSurveyCreateRequest.java`
   - contactPosition 필드 추가

4. `backend/src/main/java/com/srmanagement/service/OpenApiSurveyService.java`
   - 생성/응답 매핑 로직에 contactPosition 추가

5. `backend/src/main/resources/schema-cubrid.sql`
   - contact_position 컬럼 추가

#### Frontend (3개 파일)
1. `frontend/src/types/index.ts`
   - OpenApiSurvey 인터페이스에 contactPosition 추가

2. `frontend/src/components/survey/SurveyForm.tsx`
   - 직급 입력 필드 추가

3. `frontend/src/components/sr/OpenApiSurveyInfoCard.tsx`
   - 담당자 필드에 직급 표시

#### Database (2개 파일)
1. `backend/src/main/resources/migration_20251211_contact_position.sql`
   - 공통 마이그레이션 스크립트

2. `backend/src/main/resources/migration_20251211_contact_position_h2.sql`
   - H2 전용 마이그레이션 스크립트

---

### 기능 요약

#### ✅ 구현된 기능
1. **직급 입력**
   - 설문조사 등록/수정 폼에 직급 입력 필드 추가
   - 선택 입력 (필수 아님)
   - 플레이스홀더로 입력 예시 제공

2. **직급 표시**
   - OPEN API 현황조사 정보 카드에 직급 표시
   - 형식: "이름 (직급)" 또는 "이름"만 표시

3. **데이터 저장**
   - Database에 contact_position 컬럼으로 저장
   - NULL 허용 (기존 데이터 호환성)

4. **하위 호환성**
   - 기존 데이터에 영향 없음 (NULL 허용)
   - 직급이 없는 경우에도 정상 표시

---

### 사용 시나리오

#### 시나리오 1: 신규 설문조사 등록
1. OPEN API 현황조사 등록 페이지 접속
2. 기관명, 부서, 담당자명 입력
3. 직급 필드에 "주무관" 입력 (선택)
4. 연락처, 이메일 등 나머지 정보 입력
5. 등록 완료
6. SR 등록 시 해당 설문 연결하면 "홍길동 (주무관)" 형식으로 표시

#### 시나리오 2: 기존 데이터 조회
1. 직급 정보가 없는 기존 설문조사 조회
2. 담당자 필드에 "이름"만 표시됨
3. 정상적으로 작동 (에러 없음)

---

### 개선 효과

1. **정보 완성도 향상**
   - 담당자의 직급 정보 추가로 연락 시 편의성 증대
   - 공무원 조직 특성상 직급 정보 유용

2. **유연한 데이터 관리**
   - 선택 입력으로 기존 데이터 호환성 유지
   - 직급 정보가 없어도 시스템 정상 작동

3. **사용자 경험 개선**
   - 플레이스홀더로 입력 예시 제공
   - 정보 카드에서 한눈에 담당자 직급 확인

---

### 주의사항

- 직급 필드는 선택 입력이므로 필수 검증 없음
- 기존 데이터는 `contact_position = NULL`로 유지됨
- 엑셀 업로드 기능 사용 시 CSV 컬럼 순서 변경 필요 (향후 개선 필요)

---

### 향후 개선 가능 사항

1. **직급 코드화**
   - 공통코드 테이블에 직급 목록 관리
   - 드롭다운 선택 방식으로 변경
   - 데이터 일관성 향상

2. **엑셀 업로드 지원**
   - CSV 템플릿에 직급 컬럼 추가
   - OpenApiSurveyService의 업로드 로직 수정

3. **검색 기능**
   - 직급별 설문조사 검색/필터링
   - 담당자 검색 시 직급도 함께 검색

---

### 커밋 정보
- **커밋 날짜**: 2025-12-11
- **변경 파일**: 10개
- **추가 라인**: 약 50줄
- **수정 라인**: 약 20줄

---

## OPEN API 현황조사 담당자 및 작성상태 관리 기능 추가

### 개요
OPEN API 현황조사에 담당자 지정 및 작성상태 관리 기능을 추가했습니다. 설문조사 등록/수정 시 사용자를 담당자로 지정할 수 있고, 작성 진행 상황을 상태로 관리할 수 있습니다.

---

### 주요 변경 사항

#### 1. Backend 구현

**SurveyStatus Enum (`SurveyStatus.java`) - 신규 생성**
- 작성상태를 나타내는 Enum 추가:
  - `PENDING`: 작성대기
  - `IN_PROGRESS`: 작성중
  - `COMPLETED`: 완료

```java
package com.srmanagement.entity;

public enum SurveyStatus {
    PENDING,      // 작성대기
    IN_PROGRESS,  // 작성중
    COMPLETED     // 완료
}
```

**OpenApiSurvey Entity (`OpenApiSurvey.java`)**
- `assignee` 필드 추가: User와 ManyToOne 관계
- `status` 필드 추가: SurveyStatus enum, 기본값 PENDING

```java
// 담당자 (User 참조)
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "assignee_id")
private User assignee;

// 작성상태
@Enumerated(EnumType.STRING)
@Column(nullable = false, length = 20)
@Builder.Default
private SurveyStatus status = SurveyStatus.PENDING;
```

**DTOs**
1. `OpenApiSurveyCreateRequest.java`:
   - `assigneeId` 필드 추가 (Long)
   - `status` 필드 추가 (SurveyStatus)

2. `OpenApiSurveyResponse.java`:
   - `assignee` 필드 추가 (UserResponse)
   - `status` 필드 추가 (SurveyStatus)

**OpenApiSurveyService (`OpenApiSurveyService.java`)**
- `UserRepository` 의존성 주입 추가
- `createSurvey`: assigneeId로 User 조회 후 assignee 설정
- `updateSurvey`: assigneeId 변경 시 User 조회 후 업데이트
- Response 매핑 시 assignee 정보 포함

```java
// 담당자 설정
User assignee = null;
if (request.getAssigneeId() != null) {
    assignee = userRepository.findById(request.getAssigneeId())
            .orElseThrow(() -> new CustomException(
                "User not found with id: " + request.getAssigneeId(),
                HttpStatus.NOT_FOUND
            ));
}

OpenApiSurvey survey = OpenApiSurvey.builder()
    // ... other fields
    .assignee(assignee)
    .status(request.getStatus() != null ? request.getStatus() : SurveyStatus.PENDING)
    .build();
```

**Database Schema (`schema-cubrid.sql`)**
- `open_api_survey` 테이블에 컬럼 추가:
  - `assignee_id BIGINT`
  - `status VARCHAR(20) NOT NULL DEFAULT 'PENDING'`
  - Foreign Key: `assignee_id` → `users(id)`

**DataInitializer (`DataInitializer.java`)**
- 일반 사용자 계정 추가:
  - username: `user`
  - password: `user123`
  - name: `일반사용자`
  - role: `USER`

```java
// 초기 일반 사용자 계정 생성
if (!userRepository.existsByUsername("user")) {
    User user = User.builder()
            .username("user")
            .password(passwordEncoder.encode("user123"))
            .name("일반사용자")
            .email("user@example.com")
            .role(Role.USER)
            .build();
    userRepository.save(user);
    logger.info("Regular user created: user / user123");
}
```

---

#### 2. Frontend 구현

**Types (`types/index.ts`)**
- `SurveyStatus` 타입 추가:
  ```typescript
  export type SurveyStatus = 'PENDING' | 'IN_PROGRESS' | 'COMPLETED';
  ```

- `OpenApiSurvey` 인터페이스 수정:
  ```typescript
  export interface OpenApiSurvey {
    // ... existing fields
    assignee: User | null;
    status: SurveyStatus;
    // ...
  }
  ```

- `OpenApiSurveyCreateRequest` 타입 수정:
  ```typescript
  export type OpenApiSurveyCreateRequest = Omit<
    OpenApiSurvey,
    'id' | 'createdAt' | 'updatedAt' | 'organization' | 'assignee'
  > & {
    organizationCode: string;
    assigneeId?: number;
  };
  ```

**SurveyForm (`SurveyForm.tsx`)**
- 사용자 목록 관리:
  ```typescript
  const [userOptions, setUserOptions] = useState<User[]>([]);

  const loadUsers = async () => {
    try {
      const response = await userService.getUsers();
      setUserOptions(response.content);
    } catch (error) {
      console.error('사용자 목록 로드 실패:', error);
    }
  };
  ```

- 기본정보 섹션에 담당자 및 작성상태 필드 추가:
  ```tsx
  {/* 담당자 선택 */}
  <div className="form-group">
    <label className="form-label">담당자</label>
    <select
      name="assigneeId"
      className="form-select"
      value={formData.assigneeId || ''}
      onChange={(e) => setFormData(prev => ({
        ...prev,
        assigneeId: e.target.value ? Number(e.target.value) : undefined
      }))}
    >
      <option value="">선택 안 함</option>
      {userOptions.map(user => (
        <option key={user.id} value={user.id}>
          {user.name} ({user.username})
        </option>
      ))}
    </select>
  </div>

  {/* 작성상태 선택 */}
  <div className="form-group">
    <label className="form-label">작성상태 *</label>
    <select
      name="status"
      className="form-select"
      value={formData.status}
      onChange={(e) => setFormData(prev => ({
        ...prev,
        status: e.target.value as SurveyStatus
      }))}
      required
    >
      <option value="PENDING">작성대기</option>
      <option value="IN_PROGRESS">작성중</option>
      <option value="COMPLETED">완료</option>
    </select>
  </div>
  ```

- loadSurvey 함수에서 assignee를 assigneeId로 변환:
  ```typescript
  const { id, createdAt, updatedAt, organization, assignee, ...rest } = data;

  setFormData({
    ...sanitizedData,
    organizationCode: organization.code,
    assigneeId: assignee?.id
  } as OpenApiSurveyCreateRequest);
  ```

**Mock 데이터 수정**
- `mockData.ts`: 설문조사 목록에 assignee, status 필드 추가
- `surveyServiceMock.ts`: createSurvey에서 새 필드 처리

---

### 3. 데이터베이스 마이그레이션

**마이그레이션 스크립트**

```sql
-- open_api_survey 테이블에 컬럼 추가
ALTER TABLE open_api_survey
ADD COLUMN assignee_id BIGINT,
ADD COLUMN status VARCHAR(20) NOT NULL DEFAULT 'PENDING';

-- 외래키 제약조건 추가
ALTER TABLE open_api_survey
ADD CONSTRAINT fk_survey_assignee
FOREIGN KEY (assignee_id) REFERENCES users(id);
```

**적용 방법**
```bash
# 운영 DB
mysql -u user -p database < migration_20251211_survey_assignee_status.sql

# H2 개발 환경
# ddl-auto: update 사용 시 자동 적용
```

---

### 적용 파일 목록

#### Backend (7개 파일)
1. `backend/src/main/java/com/srmanagement/entity/SurveyStatus.java` (신규)
2. `backend/src/main/java/com/srmanagement/entity/OpenApiSurvey.java`
3. `backend/src/main/java/com/srmanagement/dto/request/OpenApiSurveyCreateRequest.java`
4. `backend/src/main/java/com/srmanagement/dto/response/OpenApiSurveyResponse.java`
5. `backend/src/main/java/com/srmanagement/service/OpenApiSurveyService.java`
6. `backend/src/main/resources/schema-cubrid.sql`
7. `backend/src/main/java/com/srmanagement/config/DataInitializer.java`

#### Frontend (5개 파일)
1. `frontend/src/types/index.ts`
2. `frontend/src/components/survey/SurveyForm.tsx`
3. `frontend/src/services/mock/mockData.ts`
4. `frontend/src/services/mock/surveyServiceMock.ts`

---

### 기능 요약

#### ✅ 구현된 기능

1. **담당자 지정**
   - 설문조사 등록/수정 시 담당자 선택 가능
   - 사용자 목록에서 선택 (드롭다운)
   - "선택 안 함" 옵션 제공
   - 표시 형식: "이름 (username)"

2. **작성상태 관리**
   - 3가지 상태 관리: 작성대기, 작성중, 완료
   - 기본값: 작성대기 (PENDING)
   - 필수 입력 필드

3. **초기 사용자 계정**
   - 관리자: `admin` / `admin123` (Role: ADMIN)
   - 일반 사용자: `user` / `user123` (Role: USER)
   - 담당자 선택 시 여러 옵션 제공 가능

4. **데이터 저장**
   - assignee: User와 ManyToOne 관계로 저장
   - status: Enum 타입으로 저장
   - 기존 데이터와 호환 (NULL 허용)

---

### 사용 시나리오

#### 시나리오 1: 신규 설문조사 등록
1. OPEN API 현황조사 등록 페이지 접속
2. 기본정보 입력 (기관명, 부서, 담당자명, 직급, 연락처, 이메일)
3. **담당자 선택**: 드롭다운에서 "일반사용자 (user)" 선택
4. **작성상태**: "작성대기" 유지 (기본값)
5. 나머지 정보 입력
6. 등록 완료
7. 목록에서 담당자와 작성상태 확인

#### 시나리오 2: 설문조사 수정 및 상태 변경
1. 기존 설문조사 수정 페이지 접속
2. 작성 진행 중이므로 **작성상태**를 "작성중"으로 변경
3. 담당자를 다른 사용자로 변경 가능
4. 수정 완료
5. 작성이 완료되면 **작성상태**를 "완료"로 변경

---

### API 명세

**1. 설문조사 생성**
```http
POST /api/surveys

Request Body:
{
  "organizationCode": "MOIS",
  "assigneeId": 2,           // Optional
  "status": "PENDING",       // Required
  // ... other fields
}

Response:
{
  "id": 1,
  "organization": {
    "code": "MOIS",
    "name": "행정안전부"
  },
  "assignee": {
    "id": 2,
    "username": "user",
    "name": "일반사용자",
    "email": "user@example.com",
    "role": "USER"
  },
  "status": "PENDING",
  // ... other fields
}
```

**2. 설문조사 수정**
```http
PUT /api/surveys/{id}

Request Body:
{
  "assigneeId": 1,           // Can be changed
  "status": "IN_PROGRESS",   // Can be changed
  // ... other fields
}
```

---

### 개선 효과

1. **업무 분담 가능**
   - 설문조사별로 담당자 지정
   - 담당자별 업무 추적 가능

2. **진행 상황 관리**
   - 작성상태로 진행도 확인
   - 작성대기 → 작성중 → 완료 흐름

3. **다중 사용자 환경 지원**
   - 여러 사용자가 각자 담당 설문 관리
   - 관리자가 전체 진행 상황 파악 가능

4. **데이터 무결성**
   - User와 관계 설정으로 참조 무결성 보장
   - Enum 타입으로 상태값 제한

---

### 주의사항

- 담당자는 선택 항목 (NULL 허용)
- 작성상태는 필수 항목 (기본값: PENDING)
- 기존 설문조사는 assignee = NULL, status = 'PENDING'으로 마이그레이션됨
- 담당자로 지정된 사용자가 삭제되어도 설문조사는 유지됨 (FK ON DELETE SET NULL 권장)

---

### 향후 개선 가능 사항

1. **담당자별 필터링**
   - 설문조사 목록에서 담당자별 필터
   - 내가 담당한 설문만 보기 기능

2. **작성상태별 통계**
   - 대시보드에 상태별 통계 표시
   - 작성 완료율 계산

3. **권한 관리**
   - 담당자만 수정 가능하도록 제한
   - 관리자는 모든 설문 수정 가능

4. **알림 기능**
   - 담당자 지정 시 이메일 알림
   - 작성상태 변경 시 알림

5. **작성기한 관리**
   - 작성 마감일 설정
   - 마감일 임박 시 알림

---

### 커밋 정보
- **커밋 해시**:
  - Backend: `1117ea2`
  - Frontend: `29b29ea`
- **커밋 날짜**: 2025-12-11
- **변경 파일**: 12개
- **추가 라인**: 약 120줄
- **수정 라인**: 약 30줄
